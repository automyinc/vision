
// AUTO GENERATED by vnxcppcodegen

#include <automy/vision/CameraInfo.hxx>
#include <automy/vision/ImageFrame.hxx>
#include <automy/vision/ImageFrame16.hxx>
#include <automy/vision/ImageFrame8.hxx>
#include <automy/vision/ImageFrameF16.hxx>
#include <automy/vision/ImageFrameF32.hxx>
#include <automy/vision/MultiImageFrame.hxx>
#include <automy/vision/PointCloud.hxx>
#include <automy/vision/StereoInfo.hxx>
#include <automy/vision/image_format_e.hxx>
#include <automy/vision/point_t.hxx>
#include <automy/vision/surface_t.hxx>

#include <automy/vision/package.hxx>
#include <vnx/vnx.h>



namespace vnx {

const TypeCode* type<::automy::vision::CameraInfo>::get_type_code() {
	return automy::vision::vnx_native_type_code_CameraInfo;
}

void type<::automy::vision::CameraInfo>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::CameraInfo());
}

void type<::automy::vision::CameraInfo>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::CameraInfo& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::ImageFrame>::get_type_code() {
	return automy::vision::vnx_native_type_code_ImageFrame;
}

void type<::automy::vision::ImageFrame>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::ImageFrame());
}

void type<::automy::vision::ImageFrame>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::ImageFrame& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::ImageFrame16>::get_type_code() {
	return automy::vision::vnx_native_type_code_ImageFrame16;
}

void type<::automy::vision::ImageFrame16>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::ImageFrame16());
}

void type<::automy::vision::ImageFrame16>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::ImageFrame16& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::ImageFrame8>::get_type_code() {
	return automy::vision::vnx_native_type_code_ImageFrame8;
}

void type<::automy::vision::ImageFrame8>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::ImageFrame8());
}

void type<::automy::vision::ImageFrame8>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::ImageFrame8& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::ImageFrameF16>::get_type_code() {
	return automy::vision::vnx_native_type_code_ImageFrameF16;
}

void type<::automy::vision::ImageFrameF16>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::ImageFrameF16());
}

void type<::automy::vision::ImageFrameF16>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::ImageFrameF16& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::ImageFrameF32>::get_type_code() {
	return automy::vision::vnx_native_type_code_ImageFrameF32;
}

void type<::automy::vision::ImageFrameF32>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::ImageFrameF32());
}

void type<::automy::vision::ImageFrameF32>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::ImageFrameF32& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::MultiImageFrame>::get_type_code() {
	return automy::vision::vnx_native_type_code_MultiImageFrame;
}

void type<::automy::vision::MultiImageFrame>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::MultiImageFrame());
}

void type<::automy::vision::MultiImageFrame>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::MultiImageFrame& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::PointCloud>::get_type_code() {
	return automy::vision::vnx_native_type_code_PointCloud;
}

void type<::automy::vision::PointCloud>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::PointCloud());
}

void type<::automy::vision::PointCloud>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::PointCloud& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::StereoInfo>::get_type_code() {
	return automy::vision::vnx_native_type_code_StereoInfo;
}

void type<::automy::vision::StereoInfo>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::StereoInfo());
}

void type<::automy::vision::StereoInfo>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::StereoInfo& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::image_format_e>::get_type_code() {
	return automy::vision::vnx_native_type_code_image_format_e;
}

void type<::automy::vision::image_format_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::image_format_e());
}

void type<::automy::vision::image_format_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::image_format_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}

const TypeCode* type<::automy::vision::point_t>::get_type_code() {
	return automy::vision::vnx_native_type_code_point_t;
}

void type<::automy::vision::point_t>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::point_t());
}

void type<::automy::vision::point_t>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::point_t& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::automy::vision::surface_t>::get_type_code() {
	return automy::vision::vnx_native_type_code_surface_t;
}

void type<::automy::vision::surface_t>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::automy::vision::surface_t());
}

void type<::automy::vision::surface_t>::create_dynamic_code(std::vector<uint16_t>& code, const ::automy::vision::surface_t& value, bool special) {
	code.push_back(CODE_OBJECT);
}


} // namespace vnx


namespace automy {
namespace vision {


void register_all_types() {
	vnx::register_type_code(::automy::vision::CameraInfo::static_create_type_code());
	vnx::register_type_code(::automy::vision::ImageFrame::static_create_type_code());
	vnx::register_type_code(::automy::vision::ImageFrame16::static_create_type_code());
	vnx::register_type_code(::automy::vision::ImageFrame8::static_create_type_code());
	vnx::register_type_code(::automy::vision::ImageFrameF16::static_create_type_code());
	vnx::register_type_code(::automy::vision::ImageFrameF32::static_create_type_code());
	vnx::register_type_code(::automy::vision::MultiImageFrame::static_create_type_code());
	vnx::register_type_code(::automy::vision::PointCloud::static_create_type_code());
	vnx::register_type_code(::automy::vision::StereoInfo::static_create_type_code());
	vnx::register_type_code(::automy::vision::image_format_e::static_create_type_code());
	vnx::register_type_code(::automy::vision::point_t::static_create_type_code());
	vnx::register_type_code(::automy::vision::surface_t::static_create_type_code());
}

static struct vnx_static_init {
	vnx_static_init() {
		register_all_types();
	}
} vnx_static_init_;

const vnx::TypeCode* const vnx_native_type_code_CameraInfo = vnx::get_type_code(vnx::Hash64(0x6520ea972c49a3f6ull));
const vnx::TypeCode* const vnx_native_type_code_ImageFrame = vnx::get_type_code(vnx::Hash64(0x763bc915ddf0300bull));
const vnx::TypeCode* const vnx_native_type_code_ImageFrame16 = vnx::get_type_code(vnx::Hash64(0x14788cd110d9c8b0ull));
const vnx::TypeCode* const vnx_native_type_code_ImageFrame8 = vnx::get_type_code(vnx::Hash64(0xdedd031b29089a86ull));
const vnx::TypeCode* const vnx_native_type_code_ImageFrameF16 = vnx::get_type_code(vnx::Hash64(0x44b11b1ff02258c5ull));
const vnx::TypeCode* const vnx_native_type_code_ImageFrameF32 = vnx::get_type_code(vnx::Hash64(0x96b32bbfb60ce4ecull));
const vnx::TypeCode* const vnx_native_type_code_MultiImageFrame = vnx::get_type_code(vnx::Hash64(0x93902e89b3c34432ull));
const vnx::TypeCode* const vnx_native_type_code_PointCloud = vnx::get_type_code(vnx::Hash64(0xa41d03221ab426c0ull));
const vnx::TypeCode* const vnx_native_type_code_StereoInfo = vnx::get_type_code(vnx::Hash64(0x5df836f6f5ebcdbdull));
const vnx::TypeCode* const vnx_native_type_code_image_format_e = vnx::get_type_code(vnx::Hash64(0xa4dcf5950509a49dull));
const vnx::TypeCode* const vnx_native_type_code_point_t = vnx::get_type_code(vnx::Hash64(0x4c4ecba106b9f17eull));
const vnx::TypeCode* const vnx_native_type_code_surface_t = vnx::get_type_code(vnx::Hash64(0xbd0ad8f0ef534d8ull));

} // namespace automy
} // namespace vision
